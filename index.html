<!DOCTYPE html>
<!-- saved from url=(0043)file:///home/joe/dev/cellularium/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellularium</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #f0f0f0;
            letter-spacing: 2px;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            padding: 12px;
            background: #16213e;
            border-radius: 8px;
            max-width: 900px;
            justify-content: center;
        }

        .element-btn {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s, border-color 0.1s;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }

        .element-btn:hover {
            transform: scale(1.08);
        }

        .element-btn.active {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .element-btn .swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-bottom: 3px;
            border: 1px solid rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            font-size: 0.85rem;
            color: #aaa;
        }

        input[type="range"] {
            width: 100px;
        }

        button.action-btn {
            padding: 8px 16px;
            background: #0f3460;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        button.action-btn:hover {
            background: #1a4a7a;
        }

        .canvas-container {
            position: relative;
            border: 3px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .stats {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
            display: flex;
            gap: 20px;
        }

        .stats span {
            color: #888;
        }
    </style>
</head>
<body>
    <h1>CELLULARIUM</h1>
    
    <div class="toolbar" id="toolbar"><button class="element-btn"><div class="swatch" style="background:#1a1a2e"></div>Air</button><button class="element-btn"><div class="swatch" style="background:#e6c86e"></div>Sand</button><button class="element-btn"><div class="swatch" style="background:#4a90d9"></div>Water</button><button class="element-btn"><div class="swatch" style="background:#8b6914"></div>Dirt</button><button class="element-btn"><div class="swatch" style="background:#5a5a5a"></div>Stone</button><button class="element-btn active"><div class="swatch" style="background:#ff4500"></div>Fire</button><button class="element-btn"><div class="swatch" style="background:#666666"></div>Smoke</button><button class="element-btn"><div class="swatch" style="background:#dddddd"></div>Steam</button><button class="element-btn"><div class="swatch" style="background:#aa0000"></div>Lava</button><button class="element-btn"><div class="swatch" style="background:#a8d8ea"></div>Ice</button><button class="element-btn"><div class="swatch" style="background:#f0f8ff"></div>Snow</button><button class="element-btn"><div class="swatch" style="background:#228b22"></div>Seed</button><button class="element-btn"><div class="swatch" style="background:#32cd32"></div>Plant</button></div>
    
    <div class="controls">
        <div class="control-group">
            <label>Brush:</label>
            <input type="range" id="brushSize" min="1" max="10" value="3">
            <span id="brushValue">3</span>
        </div>
        <div class="control-group">
            <label>Speed:</label>
            <input type="range" id="speed" min="1" max="10" value="5">
            <span id="speedValue">5</span>
        </div>
        <button class="action-btn" id="clearBtn">Clear</button>
        <button class="action-btn" id="fillBtn">Fill</button>
        <button class="action-btn" id="saveBtn">Save</button>
        <button class="action-btn" id="loadBtn">Load</button>
        <button class="action-btn" id="pauseBtn">Pause</button>
    </div>

    <div class="canvas-container">
        <canvas id="canvas" width="600" height="400"></canvas>
    </div>

    <div class="stats">
        <div>FPS: <span id="fps">42</span></div>
        <div>Cells: <span id="cellCount">6454</span></div>
        <div>Debug: <span id="debugInfo">Plant | 54° | 2psi</span></div>
    </div>

    <script>
        const ELEMENTS = {
            AIR: 0,
            SAND: 1,
            WATER: 2,
            DIRT: 3,
            STONE: 4,
            FIRE: 5,
            SMOKE: 6,
            STEAM: 7,
            LAVA: 8,
            ICE: 9,
            SNOW: 10,
            SEED: 11,
            PLANT: 12
        };

        const ELEMENT_NAMES = [
            'Air', 'Sand', 'Water', 'Dirt', 'Stone', 'Fire', 'Smoke', 'Steam', 'Lava', 'Ice', 'Snow', 'Seed', 'Plant'
        ];

        const ELEMENT_CONFIG = {
            [ELEMENTS.AIR]:   { color: '#1a1a2e', movable: false, flammable: false, baseTemp: 20, conductivity: 0.001, density: 0 },
            [ELEMENTS.SAND]:  { color: '#e6c86e', movable: true,  flammable: false, baseTemp: 20, conductivity: 0.01, density: 5 },
            [ELEMENTS.WATER]: { color: '#4a90d9', movable: true,  flammable: false, baseTemp: 30, conductivity: 0.02, density: 4 },
            [ELEMENTS.DIRT]:  { color: '#8b6914', movable: true,  flammable: false, baseTemp: 20, conductivity: 0.01, density: 4 },
            [ELEMENTS.STONE]: { color: '#5a5a5a', movable: false, flammable: false, baseTemp: 20, conductivity: 0.5, density: 10 },
            [ELEMENTS.FIRE]:  { color: '#ff4500', movable: true,  flammable: false, baseTemp: 100, conductivity: 0.1, density: -1 },
            [ELEMENTS.SMOKE]: { color: '#666666', movable: true,  flammable: false, baseTemp: 80, conductivity: 0.0005, density: -1 },
            [ELEMENTS.STEAM]: { color: '#dddddd', movable: true,  flammable: false, baseTemp: 100, conductivity: 0.0005, density: -1 },
            [ELEMENTS.LAVA]:  { color: '#aa0000', movable: true,  flammable: false, baseTemp: 500, conductivity: 0.3, density: 8 },
            [ELEMENTS.ICE]:   { color: '#a8d8ea', movable: false, flammable: false, baseTemp: 0, conductivity: 5.0, density: 3 },
            [ELEMENTS.SNOW]:  { color: '#f0f8ff', movable: true,  flammable: false, baseTemp: 10, conductivity: 0.05, density: 1 },
            [ELEMENTS.SEED]:  { color: '#228b22', movable: true,  flammable: true,  baseTemp: 30, conductivity: 2.0, density: 2 },
            [ELEMENTS.PLANT]: { color: '#32cd32', movable: false, flammable: true,  baseTemp: 30, conductivity: 5.0, density: 2 },
        };

        const CELL_SIZE = 4;
        const WIDTH = 150;
        const HEIGHT = 100;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = WIDTH * CELL_SIZE;
        canvas.height = HEIGHT * CELL_SIZE;

        let cells = new Array(WIDTH * HEIGHT).fill(null).map(() => ({ 
            type: ELEMENTS.AIR, 
            temp: 20,
            pressure: 0
        }));

        let currentElement = ELEMENTS.SAND;
        let brushSize = 3;
        let speed = 5;
        let isPaused = false;
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;

        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function idx(x, y) {
            return y * WIDTH + x;
        }

        function getCell(x, y) {
            if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return null;
            return cells[idx(x, y)];
        }

        function setCell(x, y, type, temp = null) {
            if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
            const cell = cells[idx(x, y)];
            cell.type = type;
            cell.temp = temp !== null ? temp : ELEMENT_CONFIG[type].baseTemp;
        }

        function swap(x1, y1, x2, y2) {
            if (x1 < 0 || x1 >= WIDTH || y1 < 0 || y1 >= HEIGHT) return;
            if (x2 < 0 || x2 >= WIDTH || y2 < 0 || y2 >= HEIGHT) return;
            const i1 = idx(x1, y1);
            const i2 = idx(x2, y2);
            const temp = cells[i1];
            cells[i1] = cells[i2];
            cells[i2] = temp;
        }

        function isEmpty(x, y) {
            const cell = getCell(x, y);
            return cell && cell.type === ELEMENTS.AIR;
        }

        function getCellTemp(x, y) {
            const cell = getCell(x, y);
            return cell ? cell.temp : 20;
        }

        function setCellTemp(x, y, temp) {
            const cell = getCell(x, y);
            if (cell) cell.temp = temp;
        }

        function transferHeat(x1, y1, x2, y2) {
            const cellA = getCell(x1, y1);
            const cellB = getCell(x2, y2);
            if (!cellA || !cellB) return;
            
            const configA = ELEMENT_CONFIG[cellA.type];
            const configB = ELEMENT_CONFIG[cellB.type];
            const rate = Math.min((configA.conductivity + configB.conductivity) / 2, 1.0);
            
            const diff = cellB.temp - cellA.temp;
            const transfer = diff * rate;
            
            cellA.temp += transfer;
            cellB.temp -= transfer;
        }

        function updateThermal() {
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const cell = getCell(x, y);
                    if (!cell || cell.type === ELEMENTS.AIR) continue;
                    
                    // Check all 8 neighbors
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            transferHeat(x, y, x + dx, y + dy);
                        }
                    }
                }
            }
            
            // Air cools naturally
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const cell = getCell(x, y);
                    if (cell && cell.type === ELEMENTS.AIR) {
                        cell.temp = Math.max(cell.temp - 0.2, 20);
                    }
                }
            }
        }

        function updatePressure() {
            // Reset pressure and calculate from top down
            for (let x = 0; x < WIDTH; x++) {
                let columnPressure = 0;
                for (let y = HEIGHT - 1; y >= 0; y--) {
                    const cell = getCell(x, y);
                    if (!cell) continue;
                    
                    const density = ELEMENT_CONFIG[cell.type].density;
                    
                    // Add weight from above
                    if (density > 0) {
                        columnPressure += density;
                    }
                    
                    // Store pressure in cell
                    cell.pressure = Math.max(0, columnPressure);
                    
                    // Reduce pressure for each cell we pass through
                    columnPressure = Math.max(0, columnPressure - density);
                }
            }
            
            // Pressure dissipation - high pressure spreads horizontally
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const cell = getCell(x, y);
                    if (!cell || cell.pressure < 5) continue;
                    
                    // High pressure materials spread more easily
                    const density = ELEMENT_CONFIG[cell.type].density;
                    if (density > 0 && density < 6) {
                        // Water, sand, dirt spread faster under pressure
                        cell._pressureSpread = Math.min(cell.pressure / 20, 0.5);
                    }
                }
            }
        }

        function updateMovement() {
            // Random order traversal
            const order = [];
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (Math.random() < 0.5) order.push({x, y});
                    else order.unshift({x, y});
                }
            }
            
            for (const {x, y} of order) {
                const cell = getCell(x, y);
                if (!cell) continue;
                
                const type = cell.type;
                const below = y + 1;
                const above = y - 1;
                
                // Static elements don't move
                if (!ELEMENT_CONFIG[type].movable) continue;
                
                if (type === ELEMENTS.FIRE) {
                    cell.temp = Math.max(cell.temp - 1, 20);
                    
                    // Check if there's any UNBURNT fuel nearby (not already burning hot)
                    let hasFuel = false;
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            const neighbor = getCell(x + dx, y + dy);
                            if (neighbor && ELEMENT_CONFIG[neighbor.type].flammable && neighbor.temp < 150) {
                                hasFuel = true;
                                break;
                            }
                        }
                        if (hasFuel) break;
                    }
                    
                    if (!hasFuel && Math.random() < 0.05) {
                        // Fire burns out - disappear
                        setCell(x, y, ELEMENTS.AIR);
                        continue;
                    }
                    
                    // Rise and spread - can go through smoke/steam
                    const canPassThrough = (nx, ny) => {
                        const c = getCell(nx, ny);
                        return c && (c.type === ELEMENTS.AIR || c.type === ELEMENTS.SMOKE || c.type === ELEMENTS.STEAM);
                    };
                    
                    if (above >= 0 && canPassThrough(x, above)) {
                        swap(x, y, x, above);
                    } else if (x > 0 && canPassThrough(x - 1, above) && Math.random() < 0.2) {
                        swap(x, y, x - 1, above);
                    } else if (x < WIDTH - 1 && canPassThrough(x + 1, above) && Math.random() < 0.2) {
                        swap(x, y, x + 1, above);
                    } else if (x > 0 && canPassThrough(x - 1, y) && Math.random() < 0.3) {
                        swap(x, y, x - 1, y);
                    } else if (x < WIDTH - 1 && canPassThrough(x + 1, y) && Math.random() < 0.3) {
                        swap(x, y, x + 1, y);
                    }
                    continue;
                }
                
                if (type === ELEMENTS.LAVA) {
                    cell.temp = 500; // Lava never cools
                    // Fall
                    if (below < HEIGHT && isEmpty(x, below)) {
                        swap(x, y, x, below);
                    } else if (x > 0 && isEmpty(x - 1, y) && Math.random() < 0.3) {
                        swap(x, y, x - 1, y);
                    } else if (x < WIDTH - 1 && isEmpty(x + 1, y) && Math.random() < 0.3) {
                        swap(x, y, x + 1, y);
                    }
                    continue;
                }
                
                if (type === ELEMENTS.SAND || type === ELEMENTS.DIRT) {
                    if (below < HEIGHT) {
                        const belowCell = getCell(x, below);
                        if (belowCell.type === ELEMENTS.AIR || (belowCell.type === ELEMENTS.WATER && Math.random() < 0.5)) {
                            swap(x, y, x, below);
                        } else if (x > 0 && getCell(x - 1, below).type === ELEMENTS.AIR && Math.random() < 0.4) {
                            swap(x, y, x - 1, below);
                        } else if (x < WIDTH - 1 && getCell(x + 1, below).type === ELEMENTS.AIR && Math.random() < 0.4) {
                            swap(x, y, x + 1, below);
                        }
                    }
                    continue;
                }
                
                if (type === ELEMENTS.WATER) {
                    cell.temp = Math.max(cell.temp - 0.1, 20);
                    
                    const pressureBoost = cell._pressureSpread || 0;
                    const horizChance = 0.4 + pressureBoost;
                    const downDiagChance = 0.2 + pressureBoost;
                    
                    // Water can fall through air, smoke, and steam
                    const canMoveThrough = (nx, ny) => {
                        const c = getCell(nx, ny);
                        return c && (c.type === ELEMENTS.AIR || c.type === ELEMENTS.SMOKE || c.type === ELEMENTS.STEAM);
                    };
                    
                    if (below < HEIGHT && canMoveThrough(x, below)) {
                        swap(x, y, x, below);
                    } else if (x > 0 && canMoveThrough(x - 1, y) && Math.random() < horizChance) {
                        swap(x, y, x - 1, y);
                    } else if (x < WIDTH - 1 && canMoveThrough(x + 1, y) && Math.random() < horizChance) {
                        swap(x, y, x + 1, y);
                    } else if (x > 0 && canMoveThrough(x - 1, below) && Math.random() < downDiagChance) {
                        swap(x, y, x - 1, below);
                    } else if (x < WIDTH - 1 && canMoveThrough(x + 1, below) && Math.random() < downDiagChance) {
                        swap(x, y, x + 1, below);
                    }
                    continue;
                }
                
                if (type === ELEMENTS.SMOKE) {
                    // Smoke slowly cools over time
                    cell.temp = Math.max(cell.temp - 0.03, 10);
                    
                    const isCold = cell.temp < 25;
                    
                    if (isCold && Math.random() < 0.1 && cell.temp < 21) {
                        // Cold smoke turns to dirt
                        setCell(x, y, ELEMENTS.DIRT);
                        continue;
                    }
                    
                    if (isCold) {
                        // Cold smoke falls through air, water, smoke, steam
                        const canFallThrough = (nx, ny) => {
                            const c = getCell(nx, ny);
                            return c && (c.type === ELEMENTS.AIR || c.type === ELEMENTS.WATER || c.type === ELEMENTS.SMOKE || c.type === ELEMENTS.STEAM);
                        };
                        
                        // Try to fall
                        if (below < HEIGHT && canFallThrough(x, below) && Math.random() < 0.2) {
                            swap(x, y, x, below);
                        } else if (below < HEIGHT && x > 0 && canFallThrough(x - 1, below) && Math.random() < 0.08) {
                            swap(x, y, x - 1, below);
                        } else if (below < HEIGHT && x < WIDTH - 1 && canFallThrough(x + 1, below) && Math.random() < 0.08) {
                            swap(x, y, x + 1, below);
                        } else if (x > 0 && canFallThrough(x - 1, y) && Math.random() < 0.02) {
                            swap(x, y, x - 1, y);
                        } else if (x < WIDTH - 1 && canFallThrough(x + 1, y) && Math.random() < 0.02) {
                            swap(x, y, x + 1, y);
                        }
                    } else {
                        // Hot smoke rises through air, water, and steam
                        const canMoveUp = (nx, ny) => {
                            const c = getCell(nx, ny);
                            return c && (c.type === ELEMENTS.AIR || c.type === ELEMENTS.WATER || c.type === ELEMENTS.SMOKE || c.type === ELEMENTS.STEAM);
                        };
                        
                        if (above >= 0 && canMoveUp(x, above) && Math.random() < 0.2) {
                            swap(x, y, x, above);
                        } else if (x > 0 && canMoveUp(x - 1, above) && Math.random() < 0.08) {
                            swap(x, y, x - 1, above);
                        } else if (x < WIDTH - 1 && canMoveUp(x + 1, above) && Math.random() < 0.08) {
                            swap(x, y, x + 1, above);
                        } else if (x > 0 && canMoveUp(x - 1, y) && Math.random() < 0.02) {
                            swap(x, y, x - 1, y);
                        } else if (x < WIDTH - 1 && canMoveUp(x + 1, y) && Math.random() < 0.02) {
                            swap(x, y, x + 1, y);
                        }
                    }
                    continue;
                }
                
                if (type === ELEMENTS.STEAM) {
                    cell.temp = Math.max(cell.temp - 0.03, 30);
                    
                    // Rise through air or water
                    const canMoveUp = (nx, ny) => {
                        const c = getCell(nx, ny);
                        return c && (c.type === ELEMENTS.AIR || c.type === ELEMENTS.WATER);
                    };
                    
                    if (above >= 0 && canMoveUp(x, above) && Math.random() < 0.2) {
                        const aboveCell = getCell(x, above);
                        if (aboveCell.type === ELEMENTS.WATER) {
                            setCell(x, above, ELEMENTS.WATER, cell.temp);
                            setCell(x, y, ELEMENTS.AIR);
                        } else {
                            swap(x, y, x, above);
                        }
                    } else if (x > 0 && canMoveUp(x - 1, above) && Math.random() < 0.08) {
                        const aboveCell = getCell(x - 1, above);
                        if (aboveCell.type === ELEMENTS.WATER) {
                            setCell(x - 1, above, ELEMENTS.WATER, cell.temp);
                            setCell(x, y, ELEMENTS.AIR);
                        } else {
                            swap(x, y, x - 1, above);
                        }
                    } else if (x < WIDTH - 1 && canMoveUp(x + 1, above) && Math.random() < 0.08) {
                        const aboveCell = getCell(x + 1, above);
                        if (aboveCell.type === ELEMENTS.WATER) {
                            setCell(x + 1, above, ELEMENTS.WATER, cell.temp);
                            setCell(x, y, ELEMENTS.AIR);
                        } else {
                            swap(x, y, x + 1, above);
                        }
                    } else if (x > 0 && canMoveUp(x - 1, y) && Math.random() < 0.02) {
                        swap(x, y, x - 1, y);
                    } else if (x < WIDTH - 1 && canMoveUp(x + 1, y) && Math.random() < 0.02) {
                        swap(x, y, x + 1, y);
                    }
                    continue;
                }
                
                if (type === ELEMENTS.SNOW) {
                    if (below < HEIGHT && isEmpty(x, below)) {
                        swap(x, y, x, below);
                    } else if (x > 0 && isEmpty(x - 1, below) && Math.random() < 0.3) {
                        swap(x, y, x - 1, below);
                    } else if (x < WIDTH - 1 && isEmpty(x + 1, below) && Math.random() < 0.3) {
                        swap(x, y, x + 1, below);
                    } else if (x > 0 && isEmpty(x - 1, y) && Math.random() < 0.1) {
                        swap(x, y, x - 1, y);
                    } else if (x < WIDTH - 1 && isEmpty(x + 1, y) && Math.random() < 0.1) {
                        swap(x, y, x + 1, y);
                    }
                    continue;
                }
                
                if (type === ELEMENTS.SEED) {
                    // Check for water nearby for growth
                    let hasWater = false;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const c = getCell(x + dx, y + dy);
                            if (c && c.type === ELEMENTS.WATER) {
                                hasWater = true;
                                break;
                            }
                        }
                        if (hasWater) break;
                    }
                    
                    if (hasWater && Math.random() < 0.02) {
                        setCell(x, y, ELEMENTS.PLANT);
                        continue;
                    }
                    
                    // Fall
                    if (below < HEIGHT && isEmpty(x, below)) {
                        swap(x, y, x, below);
                    } else if (x > 0 && isEmpty(x - 1, below) && Math.random() < 0.3) {
                        swap(x, y, x - 1, below);
                    } else if (x < WIDTH - 1 && isEmpty(x + 1, below) && Math.random() < 0.3) {
                        swap(x, y, x + 1, below);
                    }
                    continue;
                }
            }
        }

        function updateReactions() {
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const cell = getCell(x, y);
                    if (!cell) continue;
                    
                    const type = cell.type;
                    const temp = cell.temp;
                    const below = y + 1;
                    const above = y - 1;
                    
                    // Fire - burns adjacent flammable AND transfers heat to everything nearby
                    if (type === ELEMENTS.FIRE) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const neighbor = getCell(x + dx, y + dy);
                                if (!neighbor) continue;
                                
                                // Snow instantly turns to smoke when touched by fire
                                if (neighbor.type === ELEMENTS.SNOW) {
                                    setCell(x + dx, y + dy, ELEMENTS.SMOKE, 80);
                                    continue;
                                }
                                
                                // Always transfer heat to all other neighbors
                                neighbor.temp = Math.max(neighbor.temp, temp * 0.5);
                                
                                // Ignite flammable
                                if (ELEMENT_CONFIG[neighbor.type].flammable) {
                                    neighbor.temp = Math.max(neighbor.temp, 400);
                                }
                            }
                        }
                        continue;
                    }
                    
                    // Lava - turns adjacent water to stone + steam
                    if (type === ELEMENTS.LAVA) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const neighbor = getCell(x + dx, y + dy);
                                if (!neighbor) continue;
                                
                                // Always transfer heat
                                neighbor.temp = Math.max(neighbor.temp, temp * 0.5);
                                
                                if (neighbor.type === ELEMENTS.WATER) {
                                    setCell(x + dx, y + dy, ELEMENTS.STONE, temp);
                                    if (above >= 0 && isEmpty(x, above)) {
                                        setCell(x, above, ELEMENTS.STEAM, 120);
                                    }
                                }
                                // Ignite flammable
                                if (ELEMENT_CONFIG[neighbor.type].flammable) {
                                    neighbor.temp = Math.max(neighbor.temp, 400);
                                }
                            }
                        }
                        
                        // Below check
                        if (below < HEIGHT) {
                            const belowCell = getCell(x, below);
                            if (belowCell.type === ELEMENTS.WATER) {
                                setCell(x, below, ELEMENTS.STONE, temp);
                                setCell(x, y, ELEMENTS.STONE, temp);
                                if (above >= 0 && isEmpty(x, above)) {
                                    setCell(x, above, ELEMENTS.STEAM, 120);
                                }
                            } else if (ELEMENT_CONFIG[belowCell.type].flammable && Math.random() < 0.3) {
                                belowCell.temp = 300 + Math.random() * 200;
                            }
                        }
                        continue;
                    }
                    
                    // Water - evaporates at high temp or near hot stone
                    if (type === ELEMENTS.WATER) {
                        if (temp > 90 && Math.random() < 0.1) {
                            setCell(x, y, ELEMENTS.STEAM, 120);
                            continue;
                        }
                        
                        // Check for hot stone
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const neighbor = getCell(x + dx, y + dy);
                                if (neighbor && neighbor.type === ELEMENTS.STONE && neighbor.temp > 150 && Math.random() < 0.2) {
                                    setCell(x, y, ELEMENTS.STEAM, 120);
                                    break;
                                }
                            }
                        }
                        continue;
                    }
                    
                    // Steam - condenses when cold
                    if (type === ELEMENTS.STEAM && temp < 40 && Math.random() < 0.02) {
                        setCell(x, y, ELEMENTS.WATER, 40);
                        continue;
                    }
                    
                    // Ice - melts at high temp
                    if (type === ELEMENTS.ICE && temp > 40) {
                        setCell(x, y, ELEMENTS.WATER, 40);
                        continue;
                    }
                    
                    // Snow - melts at high temp or near fire
                    if (type === ELEMENTS.SNOW) {
                        if (temp > 40 || Math.random() < 0.01) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const neighbor = getCell(x + dx, y + dy);
                                    if (neighbor && (neighbor.type === ELEMENTS.FIRE || neighbor.temp > 80)) {
                                        if (Math.random() < 0.4) {
                                            setCell(x, y, ELEMENTS.WATER, 30);
                                            if (above >= 0 && isEmpty(x, above)) {
                                                setCell(x, above, ELEMENTS.STEAM, 60);
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        continue;
                    }
                    
// Plant - grows when near water, or decomposes if on fire
                    if (type === ELEMENTS.PLANT || type === ELEMENTS.SEED) {
                        // If burning hot, decompose to smoke or steam
                        if (temp > 200) {
                            if (Math.random() < 0.1) {
                                if (Math.random() < 0.5) {
                                    setCell(x, y, ELEMENTS.SMOKE, 80);
                                } else {
                                    setCell(x, y, ELEMENTS.STEAM, 100);
                                }
                                continue;
                            }
                        }
                        
                        // Normal plant growth logic (only if not burning)
                        if (temp < 150) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const neighbor = getCell(x + dx, y + dy);
                                    if (neighbor && neighbor.type === ELEMENTS.WATER && Math.random() < 0.15) {
                                        setCell(x + dx, y + dy, ELEMENTS.AIR);
                                        
                                        // Grow upward or sideways
                                        const growDir = Math.random();
                                        if (growDir < 0.5 && above >= 0 && isEmpty(x, above)) {
                                            setCell(x, above, ELEMENTS.PLANT, 30);
                                        } else if (growDir < 0.75 && x > 0 && isEmpty(x - 1, above)) {
                                            setCell(x - 1, above, ELEMENTS.PLANT, 30);
                                        } else if (growDir < 0.9 && x < WIDTH - 1 && isEmpty(x + 1, above)) {
                                            setCell(x + 1, above, ELEMENTS.PLANT, 30);
                                        } else if (x > 0 && isEmpty(x - 1, y) && Math.random() < 0.2) {
                                            setCell(x - 1, y, ELEMENTS.PLANT, 30);
                                        } else if (x < WIDTH - 1 && isEmpty(x + 1, y) && Math.random() < 0.2) {
                                            setCell(x + 1, y, ELEMENTS.PLANT, 30);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        continue;
                    }
                }
            }
        }

        function update() {
            updateThermal();
            updatePressure();
            updateMovement();
            updateReactions();
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const cell = getCell(x, y);
                    if (!cell) continue;
                    const type = cell.type;
                    const temp = cell.temp;
                    
                    let color = ELEMENT_CONFIG[type].color;
                    
                    // Dynamic colors based on temperature
                    if (type === ELEMENTS.FIRE) {
                        const intensity = Math.min(temp / 100, 1);
                        const r = 255;
                        const g = Math.floor(100 + intensity * 100);
                        const b = Math.floor(intensity * 50);
                        color = `rgb(${r},${g},${b})`;
                    } else if (type === ELEMENTS.LAVA) {
                        const intensity = Math.min(temp / 500, 1);
                        const r = Math.floor(150 + 100 * intensity);
                        const g = Math.floor(20 * intensity);
                        const b = Math.floor(10 * intensity);
                        color = `rgb(${r},${g},${b})`;
                    } else if (type === ELEMENTS.WATER) {
                        if (temp > 80) {
                            color = `rgb(${100 + temp}, ${150 + temp/2}, 200)`;
                        } else if (temp < 15) {
                            color = '#4a7cc9';
                        }
                    } else if (type === ELEMENTS.PLANT || type === ELEMENTS.SEED) {
                        if (temp > 200) {
                            // Burning - orange to red
                            const burn = Math.min((temp - 200) / 300, 1);
                            const r = Math.floor(200 + burn * 55);
                            const g = Math.floor(205 - burn * 180);
                            const b = Math.floor(50 - burn * 50);
                            color = `rgb(${r},${g},${b})`;
                        } else if (temp > 100) {
                            // Warming - yellow tint
                            color = `rgb(80, 200, 50)`;
                        }
                    } else if (type === ELEMENTS.SNOW) {
                        if (temp > 30) {
                            color = '#ddd';
                        }
                    } else if (type === ELEMENTS.ICE) {
                        if (temp > 20) {
                            color = '#98c8e8';
                        }
                    } else if (type === ELEMENTS.STONE) {
                        if (temp > 100) {
                            const heat = Math.min((temp - 100) / 400, 1);
                            color = `rgb(${90 + heat * 80}, ${90 + heat * 40}, ${90 + heat * 20})`;
                        }
                    } else if (type === ELEMENTS.SAND) {
                        if (temp > 80) {
                            color = '#e6b86e';
                        }
                    } else if (type === ELEMENTS.DIRT) {
                        if (temp > 60) {
                            color = '#9b7924';
                        }
                    } else if (type === ELEMENTS.SMOKE) {
                        // Hotter = more transparent
                        const alpha = Math.max(0.2, Math.min(180 - temp, 180) / 180);
                        color = `rgba(100,100,100,${alpha})`;
                    } else if (type === ELEMENTS.STEAM) {
                        // Hotter = more transparent
                        const alpha = Math.max(0.2, Math.min(200 - temp, 200) / 200);
                        color = `rgba(220,220,220,${alpha})`;
                    }
                    
                    let r, g, b, a = 255;
                    if (color.startsWith('rgba')) {
                        const match = color.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
                        if (match) {
                            r = parseInt(match[1]);
                            g = parseInt(match[2]);
                            b = parseInt(match[3]);
                            a = Math.floor(parseFloat(match[4]) * 255);
                        }
                    } else if (color.startsWith('rgb')) {
                        const match = color.match(/rgb\((\d+),(\d+),(\d+)\)/);
                        if (match) {
                            r = parseInt(match[1]);
                            g = parseInt(match[2]);
                            b = parseInt(match[3]);
                        } else {
                            r = 0; g = 0; b = 0;
                        }
                    } else {
                        r = parseInt(color.slice(1, 3), 16);
                        g = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    }
                    
                    for (let cy = 0; cy < CELL_SIZE; cy++) {
                        for (let cx = 0; cx < CELL_SIZE; cx++) {
                            const pi = ((y * CELL_SIZE + cy) * canvas.width + (x * CELL_SIZE + cx)) * 4;
                            if (a < 255) {
                                // Alpha blending
                                const existingR = data[pi];
                                const existingG = data[pi + 1];
                                const existingB = data[pi + 2];
                                data[pi] = Math.floor(existingR + (r - existingR) * a / 255);
                                data[pi + 1] = Math.floor(existingG + (g - existingG) * a / 255);
                                data[pi + 2] = Math.floor(existingB + (b - existingB) * a / 255);
                            } else {
                                data[pi] = r;
                                data[pi + 1] = g;
                                data[pi + 2] = b;
                            }
                            data[pi + 3] = 255;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function draw(x, y) {
            for (let dy = -brushSize + 1; dy < brushSize; dy++) {
                for (let dx = -brushSize + 1; dx < brushSize; dx++) {
                    if (dx * dx + dy * dy <= brushSize * brushSize) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT) {
                            if (currentElement === ELEMENTS.AIR) {
                                setCell(nx, ny, ELEMENTS.AIR);
                            } else {
                                setCell(nx, ny, currentElement);
                            }
                        }
                    }
                }
            }
        }

        function createToolbar() {
            const toolbar = document.getElementById('toolbar');
            toolbar.innerHTML = '';
            
            for (let i = 0; i < ELEMENT_NAMES.length; i++) {
                const btn = document.createElement('button');
                btn.className = 'element-btn' + (i === currentElement ? ' active' : '');
                btn.innerHTML = `<div class="swatch" style="background:${ELEMENT_CONFIG[i].color}"></div>${ELEMENT_NAMES[i]}`;
                btn.onclick = () => {
                    currentElement = i;
                    document.querySelectorAll('.element-btn').forEach((b, idx) => {
                        b.classList.toggle('active', idx === i);
                    });
                };
                toolbar.appendChild(btn);
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            mouseX = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            mouseY = Math.floor((e.clientY - rect.top) / CELL_SIZE);
            draw(mouseX, mouseY);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            mouseY = Math.floor((e.clientY - rect.top) / CELL_SIZE);
            if (isMouseDown) {
                draw(mouseX, mouseY);
            }
            if (mouseX >= 0 && mouseX < WIDTH && mouseY >= 0 && mouseY < HEIGHT) {
                const cell = getCell(mouseX, mouseY);
                document.getElementById('debugInfo').textContent = 
                    ELEMENT_NAMES[cell.type] + ' | ' + Math.round(cell.temp) + '° | ' + Math.round(cell.pressure) + 'psi';
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushValue').textContent = brushSize;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = speed;
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            for (let i = 0; i < cells.length; i++) {
                cells[i] = { type: ELEMENTS.AIR, temp: 20, pressure: 0 };
            }
        });

        document.getElementById('fillBtn').addEventListener('click', () => {
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (Math.random() < 0.3) {
                        setCell(x, y, currentElement);
                    }
                }
            }
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            const data = cells.map(c => ({ type: c.type, temp: c.temp, pressure: c.pressure }));
            localStorage.setItem('cellularium-grid', JSON.stringify(data));
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            const savedData = localStorage.getItem('cellularium-grid');
            if (savedData) {
                const data = JSON.parse(savedData);
                for (let i = 0; i < data.length && i < cells.length; i++) {
                    cells[i].type = data[i].type;
                    cells[i].temp = data[i].temp;
                    cells[i].pressure = data[i].pressure || 0;
                }
            }
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Play' : 'Pause';
        });

        function gameLoop() {
            const now = performance.now();
            frameCount++;
            
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps').textContent = fps;
                let count = 0;
                for (let i = 0; i < cells.length; i++) {
                    if (cells[i].type !== ELEMENTS.AIR) count++;
                }
                document.getElementById('cellCount').textContent = count;
            }
            
            if (!isPaused) {
                for (let i = 0; i < speed; i++) {
                    update();
                }
            }
            
            // Keep drawing while mouse is held down
            if (isMouseDown) {
                draw(mouseX, mouseY);
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        createToolbar();
        gameLoop();
    </script>


</body></html>